#ifndef ROOM_DATA_H
#define ROOM_DATA_H

#define ROOM_WIDTH 774
#define ROOM_HEIGHT 774

#define ROOM_LEVEL_COUNT 3

static const ObjectInstance room_instances[ENT_DONE] = {
  {ENT_PERSON,SIZE_MEDIUM,"Frank the Tank",1,1,1,100,SPAWN_SOLO,{GEAR_MACE, GEAR_BOW_LIGHT, GEAR_LEATHER_ARMOR, GEAR_NONE},{ABILITY_MAGIC_MISSLE, ABILITY_DONE}},
  {ENT_GOBLIN,SIZE_SMALL,"Goblin",2,5,0.25,100,SPAWN_PACK,
    {GEAR_CLUB, GEAR_NONE},
    {ABILITY_DONE},
  },
  {ENT_ORC,SIZE_MEDIUM,"Orc", 1,3,0.5f,120,SPAWN_SOLO,{GEAR_HAND_AXE,GEAR_NONE},
    {ABILITY_DONE},
  },
  {ENT_OGRE,SIZE_LARGE,"Ogre", 1,1,2,75,SPAWN_SOLO,
    {GEAR_NONE},
    {ABILITY_DONE},
  },
  {ENT_ORC_FIGHTER},
  {ENT_BERSERKER},
  {ENT_HOBGOBLIN},
  {ENT_OROG},
  {ENT_SCORPION},
  {ENT_SPIDER, SIZE_TINY,"Spider", 2,6,0,0,SPAWN_SWARM,{GEAR_NONE},
    {ABILITY_BITE_POISON,ABILITY_DONE},
  },
  {ENT_TROLL},
  {ENT_TROLL_CAVE},
  {ENT_BEAR,SIZE_LARGE,"Brown Bear",1,1,1,0,SPAWN_SOLO,{GEAR_NONE},
    {ABILITY_SWIPE,ABILITY_BITE,ABILITY_DONE},

  },
  {ENT_WOLF,SIZE_MEDIUM,"Gray Wolf",2,6,0.25,0,SPAWN_PACK,{GEAR_NONE},
    {ABILITY_CLAW,ABILITY_BITE,ABILITY_DONE},
  },
  {ENT_RAT, SIZE_SMALL, "Giant Rat",3,8,0.25,0,SPAWN_SWARM,{GEAR_NONE},
    {ABILITY_CHEW,ABILITY_DONE},
  },
};

static map_gen_t MAPS[MAP_DONE]= {
  {DARK_FOREST, MAPFLAG_FOREST},
  {DANK_DUNGEON, MAPFLAG_DUNGEON, 16,20,2,3,
    .mobs={
      MOB_LOC_DUNGEON |
        MOB_MOD_ENLARGE | MOB_MOD_WEAPON | MOB_MOD_ARMOR |
        MOB_THEME_CRITTER | MOB_THEME_PRIMITIVE | MOB_THEME_MARTIAL |
        MOB_GROUPING_SOLO | MOB_GROUPING_PAIRS|MOB_GROUPING_TROOP | MOB_GROUPING_CREW | MOB_GROUPING_SWARM
    },
    {
      {
        0,4,
        ROOM_SIZE_LARGE | ROOM_LAYOUT_ROOM | ROOM_PLACING_E | ROOM_PURPOSE_START | ROOM_SHAPE_SQUARE
      },
      {
        1,4, ROOM_LAYOUT_HALL | ROOM_SIZE_MASSIVE | ROOM_PURPOSE_CONNECT | ROOM_SHAPE_SQUARE | ROOM_ORIENT_HOR | ROOM_PLACING_E
      },
      {
        5,3, ROOM_LAYOUT_HALL | ROOM_SIZE_MASSIVE | ROOM_PURPOSE_MAX | ROOM_SHAPE_SQUARE | ROOM_ORIENT_VER | ROOM_PLACING_S
      }
    },
    MN_GRID,
  }
};

static map_node_data_t room_nodes[MAP_NODE_DONE] = {
  {MN_GRID, MAP_NODE_ROOT,NULL,1,{MN_GENERATE_ROOMS}},
  {MN_SELECT_ROOMS, MAP_NODE_SEQUENCE,NULL,2,{MN_GENERATE_ROOMS,MN_FILL_MISSING_ROOMS }},
  {MN_FILL_MISSING_ROOMS, MAP_NODE_LEAF,LeafMapFillMissing,0},
  {MN_GENERATE_ROOMS, MAP_NODE_LEAF, LeafMapGenerateRooms ,0},
  {MN_GRID_GEN, MAP_NODE_SEQUENCE, NULL,4,{MN_MAP_OUT_GRID,  MN_APPLY_SHAPES, MN_PLACE_ROOMS,MN_COMPUTE_BOUNDS}},
  {MN_MAP_OUT_GRID, MAP_NODE_LEAF, LeafMapGridLayout ,0},
  {MN_APPLY_SHAPES,MAP_NODE_LEAF, LeafMapApplyRoomShapes,0},
  {MN_PLACE_ROOMS, MAP_NODE_LEAF, LeafMapPlaceSubrooms,0}, 
  {MN_COMPUTE_BOUNDS, MAP_NODE_LEAF, LeafMapComputeBounds,0}, 
  {MN_ALLOCATE_TILES, MAP_NODE_LEAF, LeafMapAllocateTiles,0}, 
  {MN_CARVE_TILES, MAP_NODE_LEAF, LeafMapCarveTiles,0},
  {MN_GRAPH_ROOTS, MAP_NODE_LEAF, LeafMapGraphRooms,0},
  {MN_BUILD, MAP_NODE_SEQUENCE, NULL, 3,{MN_ALLOCATE_TILES, MN_CARVE_TILES, MN_CONNECT_SUB }}, 
  {MN_CONNECT_SUB, MAP_NODE_LEAF, LeafMapConnectSubrooms,0},
  {MN_DETAIL, MAP_NODE_SEQUENCE, NULL, 3,{MN_ENCASE_FLOORS, MN_PLACE_POI,MN_SET_PLAYER}},
  {MN_ENCASE_FLOORS, MAP_NODE_LEAF, LeafMapFillWalls,0},
  {MN_PLACE_POI, MAP_NODE_SEQUENCE, NULL,1,{MN_PLACE_SPAWNS}},
  {MN_SET_PLAYER, MAP_NODE_LEAF, LeafMapPlayerSpawn,0},
  {MN_PLACE_SPAWNS, MAP_NODE_LEAF, LeafMapPlaceSpawns,0},
  {MN_OPT, MAP_NODE_ROOT, NULL, 4, {MN_OPT_INIT, MN_GENERATE_ROOMS, MN_ROUTE_ROOTS, MN_SCAN, }},
  {MN_OPT_INIT, MAP_NODE_LEAF, LeafMapGenInit, 0},
  {MN_SCAN, MAP_NODE_LEAF, LeafMapGenRun, 0},
  {MN_ROUTE_ROOTS, MAP_NODE_LEAF, LeafMapGenConnectRoots, 0},
};
/*Fill missing
 * Generate Rooms (root)
 * Grid Layout (lay the roots and openings for each sub room)
 *
 * Shape rooms (roots for now)
 * Place sub rooms
 * Compute bounds
 * Allocate tiles
 * Carve Tiles
 */
static const ItemInstance room_items[GEAR_DONE] = {
  {GEAR_MACE, ITEM_WEAPON, WEAP_MACE,QUAL_COMMON},
  {GEAR_LEATHER_ARMOR,ITEM_ARMOR,ARMOR_LEATHER,QUAL_COMMON},
  {GEAR_LEATHER_CAP, ITEM_ARMOR,ARMOR_LEATHER,QUAL_COMMON},
  {GEAR_CLUB, ITEM_WEAPON, WEAP_MACE,QUAL_TRASH},
  {GEAR_HAND_AXE, ITEM_WEAPON, WEAP_AXE,QUAL_TRASH},
  {GEAR_CLOTH_ARMOR,ITEM_ARMOR,ARMOR_PADDED,QUAL_TRASH},
  {GEAR_DAGGER, ITEM_WEAPON, WEAP_DAGGER,QUAL_TRASH},
  {GEAR_BOW_LIGHT,ITEM_WEAPON, WEAP_BOW,QUAL_COMMON},

};

static const item_prop_mod_t PROP_MODS[PROP_ALL]={
  {PROP_LIGHT,{[STAT_STAMINA] = -2}},
  {PROP_HEAVY,{[STAT_STAMINA] = 2}},
  {PROP_MARTIAL,{[STAT_STAMINA] = 3}},
  {PROP_TWO_HANDED,{[STAT_STAMINA] = -2}},
  {PROP_REACH, {[STAT_REACH]= 1}},
  {PROP_RANGED, {[STAT_REACH]= 1}},
  {PROP_AMMO},
  {QUAL_TRASH,{[STAT_DAMAGE]=-2}},
  {QUAL_COMMON},
  {PROP_DONE}
};

static const loot_t LOOT[10]={
  {1,ITEM_WEAPON,GEAR_CLUB,20,QUAL_TRASH},
  {2,ITEM_WEAPON, GEAR_HAND_AXE,50,QUAL_TRASH},
  {3,ITEM_WEAPON, GEAR_HAND_AXE,75,QUAL_COMMON},
  {4,ITEM_ARMOR, GEAR_LEATHER_ARMOR, 50, QUAL_TRASH},
  {5,ITEM_ARMOR, GEAR_CLOTH_ARMOR,15, QUAL_TRASH},
  {6,ITEM_ARMOR, GEAR_CLOTH_ARMOR,25, QUAL_COMMON},
  {7,ITEM_WEAPON, GEAR_DAGGER, 35, QUAL_TRASH},
  {8,ITEM_WEAPON, GEAR_DAGGER, 50, QUAL_COMMON}
};

typedef struct {
  BehaviorID           id;
  bool                 is_root;
  BehaviorTreeType     bt_type;
  behavior_tree_node_t *(*func)(behavior_params_t *);
  bool          param_overide;
  EntityState   state;
  int           num_children;
  BehaviorID   children[5];
} BehaviorData;

static const BehaviorData room_behaviors[ BEHAVIOR_COUNT] = {
  { BEHAVIOR_NONE},
  { BEHAVIOR_CHANGE_STATE ,false,BT_LEAF,LeafChangeState,false, STATE_IDLE,0,{}},
  { BEHAVIOR_GET_TARGET ,false,BT_LEAF,LeafAcquireTarget,false, STATE_IDLE,0,{}},
  { BEHAVIOR_GET_DEST,false,BT_LEAF,LeafAcquireDestination,false, STATE_NONE,0,{}},
  { BEHAVIOR_MOVE_TO_TARGET ,false,BT_LEAF,LeafMoveToTarget,false, STATE_IDLE,0,{}},
  { BEHAVIOR_MOVE_TO_DEST,false,BT_LEAF,LeafMoveToDestination,false, STATE_NONE,0,{}},
  {BEHAVIOR_CAN_ATTACK,false,BT_LEAF,LeafCanAttackTarget,false, STATE_NONE,0,{}},
  {BEHAVIOR_ATTACK,false,BT_LEAF,LeafAttackTarget,false, STATE_NONE,0,{}},
  {BEHAVIOR_SEE,false,BT_LEAF,LeafCanSeeTarget,false, STATE_NONE,0,{}},
  {BEHAVIOR_CHECK_TURN_STATE,false, BT_LEAF,LeafCheckTurn,false,0,0,{}},
  {BEHAVIOR_TAKE_TURN,false, BT_LEAF,LeafTakeTurn,false,0,0,{}},
  { BEHAVIOR_MOVE,false,BT_SEQUENCE, NULL,true, STATE_ACTION,3,{ BEHAVIOR_GET_DEST, BEHAVIOR_MOVE_TO_DEST,BEHAVIOR_CHANGE_STATE}},
  { BEHAVIOR_CHECK_AGGRO,false,BT_SEQUENCE, NULL,true, STATE_IDLE,2,{ BEHAVIOR_GET_TARGET, BEHAVIOR_CHANGE_STATE}},
  { BEHAVIOR_ACQUIRE,false, BT_SEQUENCE, NULL,true, STATE_AGGRO,2,{ BEHAVIOR_GET_TARGET, BEHAVIOR_CHANGE_STATE}},
  {BEHAVIOR_TRY_ATTACK, false, BT_SEQUENCE,NULL,true, STATE_ATTACK,4,{BEHAVIOR_GET_TARGET,BEHAVIOR_SEE,BEHAVIOR_CAN_ATTACK,BEHAVIOR_CHANGE_STATE}},
  {BEHAVIOR_APPROACH , false,BT_SEQUENCE, NULL,false, STATE_NONE,2,{BEHAVIOR_MOVE_TO_TARGET,BEHAVIOR_TAKE_TURN}},
  { BEHAVIOR_WANDER,true,BT_SELECTOR, NULL,false, STATE_NONE,2,{ BEHAVIOR_CHECK_AGGRO, BEHAVIOR_MOVE}},
  { BEHAVIOR_SEEK, true,BT_SELECTOR,NULL,true,STATE_WANDER,2,{ BEHAVIOR_ACQUIRE,  BEHAVIOR_CHANGE_STATE}},
  { BEHAVIOR_TAKE_ACTION,true,BT_SEQUENCE,NULL,false,0,2,{ BEHAVIOR_CHECK_TURN_STATE, BEHAVIOR_TAKE_TURN}},
  { BEHAVIOR_ACTION,false,BT_SELECTOR,NULL,false,0,2,{ BEHAVIOR_TRY_ATTACK, BEHAVIOR_APPROACH}},
  { BEHAVIOR_NO_ACTION, false, BT_SEQUENCE, NULL,true, STATE_IDLE,1,{BEHAVIOR_CHANGE_STATE}},
  { BEHAVIOR_COMBAT ,true,BT_SEQUENCE,NULL,true, STATE_ACTION,2,{ BEHAVIOR_ATTACK, BEHAVIOR_CHANGE_STATE}},
  { BEHAVIOR_MOB_AGGRO ,true,BT_SELECTOR,NULL,false, 0,2,{ BEHAVIOR_ACTION, BEHAVIOR_NO_ACTION}},
};
#endif
